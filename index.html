<!doctype html>
<html>

<head>
	<title>Line Chart with Custom Tooltips</title>
	<script src="Chart.bundle.js"></script>
	<script src="utils.js"></script>
	<style>
		canvas{
			-moz-user-select: none;
			-webkit-user-select: none;
			-ms-user-select: none;
		}
		#chartjs-tooltip {
			opacity: 1;
			position: absolute;
			background: rgba(0, 0, 0, .7);
			color: white;
			border-radius: 3px;
			-webkit-transition: all .1s ease;
			transition: all .1s ease;
			pointer-events: none;
			-webkit-transform: translate(-50%, 0);
			transform: translate(-50%, 0);
		}

		.chartjs-tooltip-key {
			display: inline-block;
			width: 10px;
			height: 10px;
			margin-right: 10px;
		}
	</style>
</head>

<body>
	<a href="#" onclick="alert('click')">
		<div id="canvas-holder1" style="width:75%;">
			<canvas id="chart"/>
		</div>
	</a>
	<div>
		<a href="#" onclick="alert('click')">A Link</a>
	</div>
	<script>


		(function(Chart) {
			var helpers = Chart.helpers;
			Chart.controllers.leftToRightLine = Chart.controllers.line.extend({
				updateElement: function(point, index, reset) {
					var me = this,
							meta = me.getMeta(),
							custom = point.custom || {},
							dataset = me.getDataset(),
							datasetIndex = me.index,
							value = dataset.data[index],
							yScale = me.getScaleForId(meta.yAxisID),
							xScale = me.getScaleForId(meta.xAxisID),
							pointOptions = me.chart.options.elements.point,
							x, y,
							labels = me.chart.data.labels || [],
							includeOffset = (labels.length === 1 || dataset.data.length === 1) || me.chart.isCombo;

					// Compatibility: If the properties are defined with only the old name, use those values
					if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
						dataset.pointRadius = dataset.radius;
					}

					if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
						dataset.pointHitRadius = dataset.hitRadius;
					}

					x = reset ? xScale.right - xScale.width : xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex, includeOffset);
					y = me.calculatePointY(value, index, datasetIndex);

					// Utility
					point._xScale = xScale;
					point._yScale = yScale;
					point._datasetIndex = datasetIndex;
					point._index = index;

					// Desired view properties
					point._model = {
						x: x,
						y: y,
						skip: custom.skip || isNaN(x) || isNaN(y),
						// Appearance
						radius: custom.radius || helpers.getValueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
						pointStyle: custom.pointStyle || helpers.getValueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
						backgroundColor: me.getPointBackgroundColor(point, index),
						borderColor: me.getPointBorderColor(point, index),
						borderWidth: me.getPointBorderWidth(point, index),
						tension: meta.dataset._model ? meta.dataset._model.tension : 0,
						steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
						// Tooltip
						hitRadius: custom.hitRadius || helpers.getValueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
					};
				}
			});


			/**
			 * Helper function to traverse all of the visible elements in the chart
			 * @param chart {chart} the chart
			 * @param handler {Function} the callback to execute for each visible item
			 */
			function parseVisibleItems(chart, handler) {
				var datasets = chart.data.datasets;
				var meta, i, j, ilen, jlen;

				for (i = 0, ilen = datasets.length; i < ilen; ++i) {
					if (!chart.isDatasetVisible(i)) {
						continue;
					}

					meta = chart.getDatasetMeta(i);
					for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
						var element = meta.data[j];
						if (!element._view.skip) {
							handler(element);
						}
					}
				}
			}

			/**
			 * Helper function to get the items nearest to the event position considering all visible items in the chart
			 * @param chart {Chart} the chart to look at elements from
			 * @param position {Point} the point to be nearest to
			 * @param intersect {Boolean} if true, only consider items that intersect the position
			 * @param distanceMetric {Function} Optional function to provide the distance between
			 * @return {ChartElement[]} the nearest items
			 */
			function getNearestItems(chart, position, intersect, distanceMetric) {
				var minDistance = Number.POSITIVE_INFINITY;
				var nearestItems = [];

				if (!distanceMetric) {
					distanceMetric = helpers.distanceBetweenPoints;
				}

				parseVisibleItems(chart, function(element) {
					if (intersect && !element.inRange(position.x, position.y)) {
						return;
					}

					var center = element.getCenterPoint();
					var distance = distanceMetric(position, center);

					if (distance < minDistance) {
						nearestItems = [element];
						minDistance = distance;
					} else if (distance === minDistance) {
						// Can have multiple items at the same distance in which case we sort by size
						nearestItems.push(element);
					}
				});

				return nearestItems;
			}


			Chart.Interaction.modes.xThenNearest = function(chart, e, options) {
				var nearestItems = Chart.Interaction.modes.x(chart,e,options);
				if(nearestItems.length === 0) {

					var position = helpers.getRelativePosition(e.native, chart.chart);
					nearestItems = getNearestItems(chart, position, options.intersect, function(pt1, pt2) {
						return Math.abs(pt2.x - pt1.x);
					});
				}

				if (nearestItems.length > 1) {
					nearestItems.sort(function(a, b) {
						var sizeA = a.getArea();
						var sizeB = b.getArea();
						var ret = sizeA - sizeB;

						if (ret === 0) {
							// if equal sort by dataset index
							ret = a._datasetIndex - b._datasetIndex;
						}

						return ret;
					});
				}

				// Return only 1 item
				return nearestItems.slice(0, 1);
			};

		}).call(this, Chart);


		Chart.defaults.global.pointHitDetectionRadius = 1;
		var cursor = [{
					type: 'line',
					mode: 'vertical',
					scaleID: 'x-axes-0',
					value: new Date(),
					borderColor: '#262626',
					borderWidth: 1,
					borderDash: [2, 2],
					drawTime: 'afterDatasetsDraw'
		}];

		var customTooltips = function(tooltip) {

								// Tooltip Element
								var tooltipEl = document.getElementById('chartjs-tooltip');

								if (!tooltipEl) {
									tooltipEl = document.createElement('div');
									tooltipEl.id = 'chartjs-tooltip';
									tooltipEl.innerHTML = "";

									this._chart.canvas.parentNode.appendChild(tooltipEl);
								}

								// Hide if no tooltip
								if (tooltip.opacity === 0) {
									tooltipEl.style.opacity = 0;
									return;
								}

								// Set caret Position
								tooltipEl.classList.remove('above', 'below', 'no-transform');

								if (tooltip.yAlign) {
									tooltipEl.classList.add(tooltip.yAlign);
								} else {
									tooltipEl.classList.add('no-transform');
								}

								function getBody(bodyItem) {
									return bodyItem.lines;
								}

								// Set Text
								if (tooltip.body) {
									var titleLines = tooltip.title || [];
									var bodyLines = tooltip.body.map(getBody);
									var innerHtml = '<p>';
									titleLines.forEach(function(title) {
										innerHtml += title;
									});
									innerHtml += '</p>';
									bodyLines.forEach(function(body, i) {
										var colors = tooltip.labelColors[i];
										var style = 'background:' + colors.backgroundColor;
										style += '; border-color:' + colors.borderColor;
										style += '; border-width: 2px';
										var span = '<span class="chartjs-tooltip-key" style="' + style + '"></span>';
										innerHtml += span + body;
									});

									tooltipEl.innerHTML = innerHtml;
								}

								var position = this._chart.canvas.getBoundingClientRect();

								// Display, position, and set styles for font
								if ( tooltip.caretX > position.width / 2) {
									// when data point is right, tooltip is left
									// plus 1 pixel for overlapping the annotation line
									tooltipEl.style.left = tooltip.caretX - tooltipEl.offsetWidth + 1 + 'px';
								} else {
									// when data point is left, tooltip is right
									// minus 1 pixel for overlapping the annotation line
									tooltipEl.style.left = tooltip.caretX - 1 + 'px';
								}

								tooltipEl.style.opacity = 1;
								tooltipEl.style.top = '0px';
								tooltipEl.style.padding = tooltip.yPadding + 'px ' + tooltip.xPadding + 'px';
		};

		var lineChartData = {
			labels: ["January", "February", "March", "April", "May", "June", "July"],
			datasets: [{
				label: "My First dataset",
				borderColor: window.chartColors.red,
				pointBackgroundColor: window.chartColors.red,
				fill: false,
				data: [
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor()
				]
			}, {
				label: "My Second dataset",
				borderColor: window.chartColors.blue,
				pointBackgroundColor: window.chartColors.blue,
				fill: false,
				data: [
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor(), 
					randomScalingFactor()
				]
			}]
		};

		window.onload = function() {
			var chartEl = document.getElementById("chart");
			window.myLine = new Chart(chartEl, {
				type: 'line',
				data: lineChartData,
				options: {
					title:{
						display:true,
						text:'Chart.js Line Chart - Custom Tooltips'
					},
					tooltips: {
						enabled: false,
						mode: 'xThenNearest',
						position: 'nearest',
						custom: customTooltips
					},
					hover: {
							intersect: false,
							animationDuration: 0,
							mode: 'xThenNearest',
							onHover: function (event, activeElements) {
								if (typeof activeElements[0] !== 'undefined') {
									var currentValue = new Date();
									cursor[0].value = currentValue;
									this.update(0);
								}
							}
						},
				}
			});
		};
	</script>
</body>

</html>
